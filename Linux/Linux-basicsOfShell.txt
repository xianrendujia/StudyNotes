===================================================================================================
Shell概述
===================================================================================================
	Shell是一个命令行解释器，它为用户提供了一个向Linux内核发送请求以便运行程序的界面程序。用户可以用Shell启动、挂起、停止甚至编写一些程序。
	Shell还是一个功能强大的编程语言，易编写，易调试，灵活性较强。Shell是解释执行的脚本语言，在Shell中可以直接调用Linux系统命令。
	
===================================================================================================
Shell分类
===================================================================================================
	Shell的两种主要语法类型有Bourne和C，两种语法彼此不兼容。Bourne家族主要包括：sh、ksh、Bash、psh、zsh；C家族主要包括：csh、tcsh。
	----------------------------------------------------------
	区别sh/bash/csh/Tcsh/ksh/pdksh等shell:
		sh(全称 Bourne Shell): 是UNIX最初使用的 shell，而且在每种 UNIX 上都可以使用。
		Bourne Shell 在 shell 编程方便相当优秀，但在处理与用户的交互方便作得不如其他几种 shell。
		bash（全称 Bourne Again Shell）: LinuxOS 默认的，它是 Bourne Shell 的扩展。
		与 Bourne Shell 完全兼容，并且在 Bourne Shell 的基础上增加了很多特性。可以提供命令补全，命令编辑和命令历史等功能。它还包含了很多 C Shell 和 Korn Shell 中的优点，有灵活和强大的编辑接口，同时又很友好的用户界面。
		csh(全称 C Shell): 是一种比 Bourne Shell更适合的变种 Shell，它的语法与 C 语言很相似。
		Tcsh: 是 Linux 提供的 C Shell 的一个扩展版本。
		Tcsh 包括命令行编辑，可编程单词补全，拼写校正，历史命令替换，作业控制和类似 C 语言的语法，他不仅和 Bash Shell 提示符兼容，而且还提供比 Bash Shell 更多的提示符参数。
		ksh (全称 Korn Shell): 集合了 C Shell 和 Bourne Shell 的优点并且和 Bourne Shell 完全兼容。
		pdksh: 是 Linux 系统提供的 ksh 的扩展。
		pdksh 支持人物控制，可以在命令行上挂起，后台执行，唤醒或终止程序。
	----------------------------------------------------------
	Bash与sh兼容，现在使用的Linux就是使用Bash作为用户的基本Shell。
	打开配置文件 vi /etc/shells 可以看到支持的shell。可以切换：
	[root@localhost worlds]# vi /etc/shells
	[root@localhost worlds]# sh
	sh-4.1# 
	sh-4.1# ls
	china  china.symbolic  japan  log.hard	log.symbolic  readme
	sh-4.1# exit
	exit
	[root@localhost worlds]# 
	
===================================================================================================
Shell脚本执行方式
===================================================================================================
	第一个shell脚本：
	#!/bin/bash					# "#!"是一个约定的标记，它告诉系统这个脚本需要什么解释器来执行，即使用哪一种Shell。
	#the first shell script 	# "#"是注释行。
	echo "Hello World !"		# echo命令用于向窗口输出文本，还能支持颜色输出：echo -e "\e[1;31m hello world \e[0m"  #支持30m-37m黑-白
	----------------------------------------------------------
	运行Shell脚本有两种方法：
	（1）作为可执行程序：先赋予可执行权限再执行脚本，最常用法。
	chmod +x ./test.sh  		#赋予可执行权限
	/root/worlds/test.sh 		#可用绝对路径执行脚本
	worlds/test.sh  			#可用相对路径执行脚本
	./test.sh  					#可用相对路径执行脚本
	最后一行注意：若在当前目录执行脚本时一定要写成./test.sh，而不是test.sh，否则linux系统会去PATH里寻找有没有叫test.sh的，而只有/bin, /sbin, /usr/bin，/usr/sbin等在PATH里，你的当前目录通常不在PATH里，所以写成test.sh是会找不到命令的，要用./test.sh告诉系统说，就在当前目录找。
	（2）作为bash解释器参数：直接运行解释器，其参数就是shell脚本的文件名，如：
	/bin/sh test.sh
	/bin/bash test.sh
	
===================================================================================================
别名和快捷键
===================================================================================================
	1. 查看与设定别名
	alias，查看系统中所有命令的别名。
	alias 别名="原命令"，设定命令别名，如 alias ls="ls --color=nerver"，但是这种设定只是临时生效的。
	----------------------------------------------------------
	2. 别名永久生效与删除别名
	vi ~/.bashrc，写入环境变量配置文件，然后重新登陆或者执行命令 source .bashrc 即可生效。
	其中~代表当前用户的家目录，如root或home。
	unalias 别名，删除别名，这种也是临时的。要永久删除则也是修改.bashrc文件。
	----------------------------------------------------------
	3. 命令生效的顺序？如别名优先于原命令
	第一顺位执行用绝对路径或相对路径执行的命令；
	第二顺位执行别名；
	第三顺位执行Bash内部命令；
	第四顺位执行按照$PATH环境变量定义的目录查找顺序找到的第一个命令。
	----------------------------------------------------------
	4. 常用快捷键
	ctrl+c 强制终止当前命令
	ctrl+l 清屏
	ctrl+a 光标移动到命令行首
	ctrl+e 光标移动到命令行尾
	ctrl+u 从光标所在位置删除到行首
	ctrl+z 把命令放入后台
	ctrl+r 在历史命令中搜索
	
===================================================================================================
历史命令
===================================================================================================
	1. history [选项] [历史命令保存文件]
	-c 清空历史命令
	-w 把缓存中的历史命令写入历史命令保持文件~/.bash_history
	直接执行 history 命令可以看到显示命令比 cat .bash_history 显示的要多？
		因为history保存有本次登陆操作命令，而该文件正常情况下是在本次登录退出时才会将本次登陆操作命令写入。
		如果要同步写入该文件执行 history -w 命令即可。
	历史命令条数：
		默认会保持1000条，可以在环境变量配置文件 /etc/profile 中修改HISTSIZE=1000。
	历史命令的调用：
		使用上下箭头调用历史命令；
		使用 "!n" 重复执行第n条历史命令；
		使用 "!!" 重复执行第n条历史命令；
		使用 "!字串" 重复执行最后一条以字串开头的命令；
		
===================================================================================================
输出重定向
===================================================================================================
	1. 标准输入输出
	设备       设备文件名     文件描述符    类型
	键盘       /dev/stdin       0           标准输入
	显示器     /dev/stdout      1           标准输出
	显示器     /dev/stderr      2           标准错误输出
	----------------------------------------------------------
	2. 输出重定向
	类型                   		符号                	 		 作用	
	标准输出重定向         		命令 >  文件         	 		 以覆盖的方式，把命令的正确输出保存到指定的文件或设备当中
								命令 >> 文件	    	 		 以追加的方式，把命令的正确输出保存到指定的文件或设备当中
	标准错误输出重定向	   		错误命令 2>  文件    	 		 以覆盖的方式，把命令的错误输出保存到指定的文件或设备当中			  
								错误命令 2>> 文件   	 		 以追加的方式，把命令的错误输出保存到指定的文件或设备当中
	正确输出和错误输出同时保存  命令 >   文件 2>&1		 		 以覆盖的方式，把命令的正确输出和错误输出都保存到同一个文件中
								命令 >>  文件 2>&1	   （常用）	 以追加的方式，把命令的正确输出和错误输出都保存到同一个文件中
								命令 &>  文件			 		 以覆盖的方式，把命令的正确输出和错误输出都保存到同一个文件中
								命令 &>> 文件		   （常用）	 以追加的方式，把命令的正确输出和错误输出都保存到同一个文件中
								命令 >>  文件1 2>>文件2（常用）	 把命令的正确输出追加到文件1；把错误输出追加到文件2
	----------------------------------------------------------
	补充：/dev/null 文件
	如果希望执行某个命令，但又不希望在屏幕上显示输出结果，那么可以将输出重定向到 /dev/null：$ command > /dev/null
	这里的 /dev/null 是一个特殊的文件，写入到它的内容都会被丢弃；如果尝试从该文件读取内容，那么什么也读不到。
	但是 /dev/null 文件非常有用，将命令的输出重定向到它，会起到"禁止输出"的效果。
	如果希望屏蔽 stdout 和 stderr ，可以这样写：$ command > /dev/null 2>&1
	----------------------------------------------------------
	3. 输入重定向
	和输出重定向一样，也可以从文件获取输入，语法为：
	command1 < file1
	这样，本来需要从键盘获取输入的命令会转移到文件读取内容。
	注意：输出重定向是大于号(>)，输入重定向是小于号(<)。
	command < file	将输入重定向到 file。
	n <& m			将输入文件 m 和 n 合并。
	<< tag			将开始标记 tag 和结束标记 tag 之间的内容作为输入。
	实例：
	wc [选项] [文件名]，选项 -c 统计字节数； -w 统计单词数； -l 统计行数。
	要统计 users 文件的行数,执行以下命令：
	$ wc -l users
	2 users
	也可以将输入重定向到 users 文件：
	$ wc -l < users
	2 
	注意：上面两个例子的结果不同：第一个例子，会输出文件名；第二个不会，因为它仅仅知道从标准输入读取内容。
	command1 < infile > outfile
	同时替换输入和输出，执行command1，从文件infile读取内容，然后将输出写入到outfile中。
	
===================================================================================================
管道符
===================================================================================================
	1. 多命令顺序执行
	多命令执行符	格式			 作用
	;				命令1;命令2		 多个命令顺序执行，命令之间没有逻辑关系，即使某命令出错但不会影响后面命令执行。
	&&				命令1&&命令2	 逻辑与，仅当命令1执行正确时命令2才会执行。
	||				命令1||命令2	 逻辑或，当命令1执行正确时则命令2不会执行，当命令1执行不正确时命令2才会执行。
	实例：
	date ; lssss ; pwd
	ls && echo yes 
	lssss || echo no
	ls && echo yes || echo no
	----------------------------------------------------------
	2. 管道符
	格式： 命令1 | 命令2    #命令1的正确输出作为命令2的操作对象
	实例：
	假如我们要查看/etc/下的文件，有很多查看起来不方便，我们可以将结果重定向到某文件再查看，如
	ls -l /etc/ > abc
	more abc
	这时利用管道符就可简单达到目的： ls -l /etc/ | more
	还可使用多个管道符：
	netstat -an | grep tcp
	netstat -an | grep tcp | grep ESTABLISHED
	netstat -an | grep tcp | grep ESTABLISHED | wc -l

===================================================================================================
通配符
===================================================================================================
	1. 通配符
	通配符		作用
	？			匹配任意一个字符
	*			匹配0个或任意多个任意字符
	[]			匹配中括号内任意一个字符，如[abc]
	[-]			匹配中括号内指定范围内的任意一个字符，如[a-z]
	[^]			逻辑非，匹配不是中括号内的一个字符，如[^0-9]
	实例：
	ls china?
	ls china*
	ls china[0-9]
	----------------------------------------------------------
	2. Bash中其他特殊符号
	符号		作用
	''			单引号。在单引号中所有的特殊符号，如“$”和“`”（反引号）也都没有特殊含义。
	""			双引号。在双引号中特殊符号都没有特殊含义，但是有几个例外：“$”（调用变量值）、“`”（引用命令）和“\”（转义符）。
	``			反引号。在反引号中的内容是系统命令，在Bash中会先执行它。和$()作用一样，推荐使用后者，因为反引号容易看错。
	$()			和反引号作用一样，用来引用系统命令。
	#			在Shell脚本中，#开头的行表示注释。
	$			用于调用变量的值，如需要调用变量name的值时，使用$name。
	\			转义符。跟在\之后的特殊符号将失去特殊含义，变成普通字符。如\$将输出“$”符号本身而不是当作变量引用。
	实例：
	[root@localhost ~]# name=zhangsan
	[root@localhost ~]# echo $name
	zhangsan
	[root@localhost ~]# echo '$name'
	$name
	[root@localhost ~]# echo "$name"
	zhangsan
	[root@localhost ~]# echo \$name
	$name
	[root@localhost ~]# echo ls
	ls
	[root@localhost ~]# echo `ls`
	anaconda-ks.cfg install.log install.log.syslog
	[root@localhost ~]# echo $(ls)
	anaconda-ks.cfg install.log install.log.syslog
	
	
	
	
	
	
	
	
	
	
	

	
	
	
	
	
